import * as Redux from 'redux';
import * as ReactRedux from 'react-redux';

let _store = null;
let _hooks = [];
let _prevState = {};

const HOOK_ACTION = 1;
const HOOK_REDUCE = 2;
const HOOK_LISTEN = 3;

// simplified version of
// https://github.com/gaearon/redux-thunk/blob/master/src/index.js

function _thunkMiddleware(store) {
    return function (next) {
        return function (action) {
            if (typeof action === 'function') {
                return action();
            }
            return next(action);
        }
    }
}

function _reducer(state, action) {

    let type = action.type,
        args = action.args || {};

    if (type === 'set') {
        return Object.assign({}, state, args);
    }

    let hooks = _hooks.filter(h => h[0] === HOOK_REDUCE && h[1] === type);

    if (!hooks.length) {
        return state;
    }

    return hooks.reduce((s, h) =>
            Object.assign({}, s, h[3](s, args)),
        state);
}

function _listener() {
    let hooks = _hooks.filter(h => h[0] === HOOK_LISTEN),
        state = _store.getState();

    hooks.forEach(h => {
        let prop = h[1];
        if (state[prop] !== _prevState[prop]) {
            h[3](state[prop], _prevState[prop]);
            _prevState[prop] = state[prop];
        }
    });
}


/**
 * @memberOf module:app
 *
 * @desc
 *
 * Returns the global store.
 *
 */
function store() {
    if (!_store) {
        _store = Redux.createStore(
            _reducer,
            {},
            Redux.applyMiddleware(_thunkMiddleware));
    }
    _store.subscribe(_listener);
    return _store;
}

/**
 * @memberOf module:app
 * @param {string} type Action type
 * @param {object} args Arguments to the action
 *
 * @desc
 *
 * Performs an action. If there's a hook for this action, runs it,
 * otherwise dispatches an object `{type, args}` to the store.
 *
 */
function perform(type, args) {
    let hooks = _hooks.filter(h => h[0] === HOOK_ACTION && h[1] === type);
    if (!hooks.length)
        return _store.dispatch({type, args});
    hooks.forEach(h => _store.dispatch(() => h[3](args)));
}

/**
 * @memberOf module:app
 * @param {object} args Arguments to the action
 *
 * @desc
 *
 * Dispatches a trivial action which merges args to the store.
 *
 */
function set(args) {
    perform('set', args);
}

/**
 * @memberOf module:app
 * @param {string} key
 *
 * @desc
 *
 * Returns the store value under this key.
 *
 */
function get(key) {
    return (_store.getState() || {})[key];
}


/**
 * @memberOf module:app
 * @param {class} klass Component class
 * @param {array|object} props List of keys to bind or an object `{propName: storeKey}`
 *
 * @desc
 *
 * Connects the class to the store and binds given state keys to its props.
 *
 */
function connect(klass, props = []) {
    let mapper = Array.isArray(props) ?
        state => props.reduce((res, p) => ({...res, [p]: state[p]}), {}) :
        state => Object.keys(props).reduce((res, k) => ({...res, [k]: state[props[k]]}), {});

    return ReactRedux.connect(mapper)(klass);
}

/**
 * @memberOf module:app
 * @hideconstructor
 *
 * @desc
 *
 * Base class for plugins.
 */
class Plugin {

    /**
     * @desc
     *
     * Callback invoked during App startup. Declare your hooks and event handlers here.
     */
    init() {

    }

    /**
     *
     * @param {string} type Action type
     * @param {function} fn Action hook
     *
     * @desc
     *
     * Declares a hook for the action. The hook accepts a single args objects (as given to `app.perform`),
     * it's recommended to destructure it for clarity:
     *
     * ```
     * class Plugin extends app.Plugin {
     *    init() {
     *        this.action('doSomething', ({foo, bar}) => ....
     *    }
     *
     * // somewhere else
     * app.perform('doSomething', {foo: 11, bar: 22})
     *  ```
     */
    action(type, fn) {
        _hooks.push([HOOK_ACTION, type, this, fn]);
    }

    /**
     *
     * @param {string} type Action type
     * @param {function} fn Reducer hook
     *
     * @desc
     *
     * Declares a reducer hook for the action. The hook accepts `state` and `args` object
     * and should return an object to be merged into the state (NB: not the whole state!):
     *
     *  ```
     * class Plugin extends app.Plugin {
     *    init() {
     *
     *        this.reducer('processSomething', (state, {foo, bar}) => {
     *            ....
     *            return {blah: 125}
     *        }
     *    }
     * }
     *
     * // somewhere else
     * app.perform('processSomething', {foo: 11, bar: 22})
     *
     *  ```
     *
     *
     */
    reducer(type, fn) {
        _hooks.push([HOOK_REDUCE, type, this, fn]);
    }

    /**
     *
     * @param {string} prop Property name
     * @param {function} fn Update hook
     *
     * @desc
     *
     * Subscribes to a property change event in the store.
     * The callback function gets called with two arguments: `value` and `prevValue` when the property changes.
     *
     *  ```
     * class Plugin extends app.Plugin {
     *    init() {
     *
     *        this.subscribe('someStateVar', (value, prevValue) => {
     *            console.log(someStateVar, 'changed from', prevValue, 'to', value);
     *        }
     *    }
     * }
     *
     * // this will invoke the hook
     * app.set({someStateVar: 42})
     *
     *  ```
     *
     *
     */
    subscribe(prop, fn) {
        _hooks.push([HOOK_LISTEN, prop, this, fn]);
    }

    deinit() {
        _hooks = _hooks.filter(h => h[2] !== this);
    }
}

export default {
    Plugin,
    store,
    get,
    set,
    connect,
    perform
}