import ol from 'ol-all';
import proj4 from 'proj4/lib';

import loader from './loader';
import config from '../app/config';

import helpers from './helpers';

function initViewOptions() {
    // center is the only mandatory config option
    let opts = {
        center: config.object('map.center')
    };

    let projection = config.str('map.crs.client');
    if (projection)
        opts.projection = projection;

    let scales = config.object('map.scales');
    if (scales) {
        opts.minResolution = helpers.scaleToResolution(scales[0]);
        opts.maxResolution = helpers.scaleToResolution(scales[scales.length - 1]);
        opts.resolution = helpers.scaleToResolution(scales[scales.length >> 1]);
    } else {
        // if no scales, zoom must be given
        opts.zoom = config.number('map.zoom') || 10;
    }

    let extent = config.object('map.extent');
    if (extent) {
        opts.extent = extent;
    }

    return opts;
}


/**
 * @desc
 *
 * Wraps `ol.Map` and provides some useful utilities.
 *
 */
class TMap extends ol.Map {
    constructor() {
        ol.proj.setProj4(proj4);

        let defs = config.object('map.crs.defs');
        if (defs) {
            Object.keys(defs).forEach(d => proj4.defs(d, defs[d]));
        }

        super({
            controls: [],
            interactions: [],
            view: new ol.View(initViewOptions())
        });

        this.currentMode = null;

        this.groups = {
            'background': new ol.layer.Group({zIndex: 0, kind: '_BACKGROUND'}),
            'project': new ol.layer.Group({zIndex: 1, kind: '_PROJECT'}),
            'service': new ol.layer.Group({zIndex: 2, kind: '_SERVICE'})
        };

        this.addLayer(this.groups.background);
        this.addLayer(this.groups.project);
        this.addLayer(this.groups.service);
    }

    attachLayer(group, layer) {
        this.groups[group].getLayers().push(layer);
        return layer;
    }

    serviceLayer(kind, createFn = null) {
        let la = this.findLayer(la => la.get('kind') === kind, this.groups.service);
        if (la)
            return la;
        if (createFn) {
            la = createFn();
            la.set('kind', kind);
            return this.attachLayer('service', la);
        }
        return null;
    }

    removeServiceLayer(kind) {
        let la = this.serviceLayer(kind);
        if (la) {
            this.groups.service.getLayers().remove(la);
        }
    }

    setScale(scale) {
        this.getView().setResolution(helpers.scaleToResolution(scale));
    }

    getScale() {
        return helpers.resolutionToScale(this.getView().getResolution())
    }

    async init(target) {
        await loader.load(this);

        this.setTarget(target);
        this.defaultMode();

        this.changed();
        this.getView().changed();

    }

    setMode(name, cursor = null, interactions = null) {
        if (name === this.currentMode)
            return;

        if (!name) {
            cursor = 'default';
            interactions = [
                new ol.interaction.DragPan(),
                new ol.interaction.PinchZoom(),
                new ol.interaction.MouseWheelZoom(),
            ]
        }

        this.getInteractions().clear();
        for (let int of interactions)
            this.addInteraction(int);

        this.getTargetElement().style.cursor = cursor;
        this.currentMode = name;
    }

    defaultMode() {
        this.setMode('');
    }

    rootLayer() {
        return this.getLayerGroup();
    }

    findLayer(fn, startLayer = null) {
        let found = null;

        function _walk(layer) {
            if (found)
                return;

            if (fn(layer)) {
                found = layer;
                return;
            }

            if (layer.getLayers) {
                layer.getLayers().forEach(sub => _walk(sub));
            }
        }

        _walk(startLayer || this.rootLayer());
        return found;
    }

    getLayerById(uid) {
        return this.findLayer(la => ol.getUid(la) === uid);
    }

    enumLayers(startLayer = null) {
        let found = [];

        function _enum(layer) {
            found.push(layer);
            if (layer.getLayers)
                layer.getLayers().forEach(sub => _enum(sub));
        }

        _enum(startLayer || this.rootLayer());
        return found;
    }

    getLayersOfKind(kind, startLayer = null) {
        return this.enumLayers(startLayer).filter(la => la.get('kind') === kind);
    }


}

export default TMap;
