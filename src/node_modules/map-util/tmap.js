import ol from 'ol-all';
import proj4 from 'proj4/lib';

import loader from './loader';
import config from '../app/config';

import helpers from './helpers';


/**
 * @desc
 *
 * Wraps `ol.Map` and provides some useful utilities.
 *
 */
class TMap extends ol.Map {
    constructor() {
        super({
            controls: [],
            interactions: [],
        });
    }

    init() {
        ol.proj.setProj4(proj4);

        let defs = config.object('map.crs.defs');
        if (defs) {
            Object.keys(defs).forEach(d => proj4.defs(d, defs[d]));
        }

        this.setView(new ol.View(this.initViewOptions()));

        this.currentMode = null;
        this.modeStack = [];

        this.groups = {
            'background': new ol.layer.Group({zIndex: 0, kind: '_BACKGROUND'}),
            'project': new ol.layer.Group({zIndex: 1, kind: '_PROJECT'}),
            'service': new ol.layer.Group({zIndex: 2, kind: '_SERVICE'})
        };

        this.addLayer(this.groups.background);
        this.addLayer(this.groups.project);
        this.addLayer(this.groups.service);

        this.defaultInteractions = {
            'DragPan': new ol.interaction.DragPan({
                kinetic: null
            }),
            'PinchZoom': new ol.interaction.PinchZoom({
                constrainResolution: true
            }),
            'MouseWheelZoom': new ol.interaction.MouseWheelZoom({
                constrainResolution: true
            })
        };

    }

    initViewOptions() {
        let opts = {};

        this.scales = [...config.object('map.scales')].sort((a, b) => b - a);
        this.resolutions = this.scales.map(helpers.scaleToResolution);

        opts.resolutions = this.resolutions;

        opts.minResolution = opts.resolutions[opts.resolutions.length - 1];
        opts.maxResolution = opts.resolutions[0];

        let scale = config.number('map.scale');

        opts.resolution = scale ? helpers.scaleToResolution(scale)
            : opts.resolutions[opts.resolutions.length >> 1];

        let projection = config.str('map.crs.client');
        if (projection)
            opts.projection = projection;

        let extent = config.object('map.extent');
        if (extent) {
            opts.extent = extent;
        }

        let center = config.object('map.center');
        if (center) {
            opts.center = center;
        } else {
            opts.center = ol.extent.getCenter(extent);
        }

        return opts;
    }


    attachLayer(group, layer) {
        this.groups[group].getLayers().push(layer);
        return layer;
    }

    serviceLayer(kind, createFn = null) {
        let la = this.findLayer(la => la.get('kind') === kind, this.groups.service);
        if (la)
            return la;
        if (createFn) {
            la = createFn();
            la.set('kind', kind);
            return this.attachLayer('service', la);
        }
        return null;
    }

    removeServiceLayer(kind) {
        let la = this.serviceLayer(kind);
        if (la) {
            this.groups.service.getLayers().remove(la);
        }
    }

    getScales() {
        return this.scales;
    }

    setScaleLevel(n) {
        this.getView().setResolution(this.resolutions[n]);
    }

    setScale(scale) {
        return this.getView().setResolution(helpers.scaleToResolution(scale));
    }

    getScale() {
        return helpers.resolutionToScale(this.getView().getResolution())
    }

    getScaleLevel() {
        let res = this.getView().getResolution();

        let nearest = 0;
        this.resolutions.forEach((r, n) => {
            if (Math.abs(r - res) < Math.abs(this.resolutions[nearest] - res))
                nearest = n
        });

        return nearest;
    }

    async load(target) {
        await loader.load(this);

        this.setTarget(target);
        this.setDefaultMode();

        this.changed();
        this.getView().changed();

    }

    getModeName() {
        return this.currentMode.name;
    }

    setMode(opts) {
        this.currentMode = opts;

        if (opts.interactions) {
            this.getInteractions().clear();
            opts.interactions.forEach(int => {
                if (typeof(int) === 'string')
                    int = this.defaultInteractions[int];
                this.addInteraction(int)
            });
        }

        if (opts.cursor && this.getTargetElement()) {
            this.getTargetElement().style.cursor = opts.cursor;
        }
    }

    pushMode(opts) {
        this.modeStack.push(this.currentMode);
        this.setMode(opts);
    }

    popMode() {
        if (this.modeStack.length)
            this.setMode(this.modeStack.pop());
    }

    setDefaultMode() {
        this.setMode({
            name: '',
            cursor: 'default',
            interactions: [
                'DragPan',
                'PinchZoom',
                'MouseWheelZoom'
            ]
        });
    }

    rootLayer() {
        return this.getLayerGroup();
    }

    findLayer(fn, startLayer = null) {
        let found = null;

        function _walk(layer) {
            if (found)
                return;

            if (fn(layer)) {
                found = layer;
                return;
            }

            if (layer.getLayers) {
                layer.getLayers().forEach(sub => _walk(sub));
            }
        }

        _walk(startLayer || this.rootLayer());
        return found;
    }

    getLayerById(uid) {
        return this.findLayer(la => ol.getUid(la) === uid);
    }

    enumLayers(startLayer = null) {
        let found = [];

        function _enum(layer) {
            found.push(layer);
            if (layer.getLayers)
                layer.getLayers().forEach(sub => _enum(sub));
        }

        _enum(startLayer || this.rootLayer());
        return found;
    }

    getLayersOfKind(kind, startLayer = null) {
        return this.enumLayers(startLayer).filter(la => la.get('kind') === kind);
    }


}

export default TMap;
