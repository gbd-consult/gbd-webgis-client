import _ from 'lodash';
import ol from 'ol-all';
import proj4 from 'proj4/lib';

import tlayer from './tlayer';
import config from '../app/config';

import helpers from './helpers';


/**
 * @desc
 *
 * Wraps `ol.Map` and provides some useful utilities.
 *
 */
class TMap extends ol.Map {
    constructor() {
        super({
            controls: [],
            interactions: [],
        });
    }

    init() {
        ol.proj.setProj4(proj4);

        let defs = config.object('map.crs.defs');
        if (defs) {
            Object.keys(defs).forEach(d => proj4.defs(d, defs[d]));
        }

        this.setView(new ol.View(this.initViewOptions()));

        this.currentMode = null;
        this.modeStack = [];

        this.groups = {};
        this.groupIndex = 1;

        this.addGroup('project');
        this.addGroup('service');

        this.defaultInteractions = {
            'DragPan': new ol.interaction.DragPan({
                kinetic: new ol.Kinetic(-0.005, 0.05, 100)
            }),
            'PinchZoom': new ol.interaction.PinchZoom({
                constrainResolution: true
            }),
            'MouseWheelZoom': new ol.interaction.MouseWheelZoom({
                constrainResolution: true
            })
        };

    }

    initViewOptions() {
        let opts = {};

        this.scales = [...config.object('map.scales')].sort((a, b) => b - a);
        this.resolutions = this.scales.map(helpers.scaleToResolution);

        //opts.resolutions = this.resolutions;

        opts.minResolution = this.resolutions[this.resolutions.length - 1];
        opts.maxResolution = this.resolutions[0];

        let scale = config.number('map.scale');

        opts.resolution = scale ? helpers.scaleToResolution(scale)
            : this.resolutions[this.resolutions.length >> 1];

        let projection = config.str('map.crs.client');
        if (projection)
            opts.projection = projection;

        let extent = config.object('map.extent');
        if (extent) {
            opts.extent = extent;
        }

        let center = config.object('map.center');
        if (center) {
            opts.center = center;
        } else {
            opts.center = ol.extent.getCenter(extent);
        }

        return opts;
    }

    addGroup(group) {
        if(this.groups[group])
            return;
        let g = new ol.layer.Group({name: group});
        this.getLayers().insertAt(1, g);
        this.groups[group] = g;
    }

    attachLayer(group, layer) {
        this.addGroup(group);
        this.groups[group].getLayers().insertAt(0, layer);
        return layer;
    }

    serviceLayer(kind, createFn = null) {
        let la = this.findLayer(la => la.get('kind') === kind, this.groups.service);
        if (la)
            return la;
        if (createFn) {
            la = createFn();
            la.set('kind', kind);
            la.set('isService', true);
            return this.attachLayer('service', la);
        }
        return null;
    }

    removeServiceLayer(kind) {
        let la = this.serviceLayer(kind);
        if (la) {
            this.groups.service.getLayers().remove(la);
        }
    }

    getGroup(group) {
        return this.groups[group];
    }

    removeGroup(group) {
        if (this.groups[group]) {
            this.removeLayer(this.groups[group]);
            delete this.groups[group];
        }
    }


    getScales() {
        return this.scales;
    }

    setScaleLevel(n) {
        if (n < 0) n = 0;
        if (n >= this.resolutions.length) n = this.resolutions.length - 1;
        this.getView().setResolution(this.resolutions[n]);
    }

    setScale(scale) {
        return this.getView().setResolution(helpers.scaleToResolution(scale));
    }

    getScale() {
        return helpers.resolutionToScale(this.getView().getResolution())
    }

    getBounds() {
        return config.object('map.extent');
    }

    getScaleLevel() {
        let res = this.getView().getResolution();

        let nearest = 0;
        this.resolutions.forEach((r, n) => {
            if (Math.abs(r - res) < Math.abs(this.resolutions[nearest] - res))
                nearest = n
        });

        return nearest;
    }

    getLayerRoot() {
        return this._layerRoot;
    }

    getSelectedLayer() {
        return this._selectedLayer;
    }

    setSelectedLayer(la) {
        this._selectedLayer = la;
        this.layerTreeChanged();
    }

    layerTreeChanged() {
        this._layerRoot.update();
        this.dispatchEvent('layerTreeChanged');
    }

    async load(target) {
        this._layerRoot = await tlayer.create({type: 'root', layers: config.object('map.layers')});

        let mapLayers = [];
        this._layerRoot.enumerate((la, parent) => {
            la.parent = parent;
            la.map = this;
            mapLayers.push(la.getMapLayer());
        });

        mapLayers.filter(Boolean).forEach(la => this.attachLayer('project', la));
        this.getView().on('change:resolution', () => this.layerTreeChanged());

        this.setTarget(target);
        this.setDefaultMode();

        this.changed();
        this.getView().changed();
        this.layerTreeChanged();

        return this;
    }

    getModeName() {
        return this.currentMode.name;
    }

    setMode(opts) {
        if (this.currentMode && this.currentMode.onLeave)
            this.currentMode.onLeave();

        this.currentMode = opts;

        if (opts.interactions) {
            this.getInteractions().clear();
            opts.interactions.forEach(int => {
                if (typeof(int) === 'string')
                    int = this.defaultInteractions[int];
                this.addInteraction(int)
            });
        }

        if (opts.cursor && this.getTargetElement()) {
            this.getTargetElement().style.cursor = opts.cursor;
        }

        if (this.currentMode && this.currentMode.onEnter)
            this.currentMode.onEnter();


    }

    pushMode(opts) {
        this.modeStack.push(this.currentMode);
        this.setMode(opts);
    }

    popMode() {
        if (this.modeStack.length)
            this.setMode(this.modeStack.pop());
    }

    setDefaultMode() {
        this.setMode({
            name: '',
            cursor: 'default',
            interactions: [
                'DragPan',
                'PinchZoom',
                'MouseWheelZoom'
            ]
        });
    }

    findLayer(fn, startLayer = null) {
        let found = null;

        function _walk(layer) {
            if (found)
                return;

            if (fn(layer)) {
                found = layer;
                return;
            }

            if (layer.getLayers) {
                layer.getLayers().forEach(sub => _walk(sub));
            }
        }

        _walk(startLayer || this.getLayerGroup());
        return found;
    }

}

export default TMap;
