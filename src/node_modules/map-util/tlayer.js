import _ from 'lodash';
import ol from 'ol-all';

import wms from './wms';
import helpers from './helpers';

let types = {
    osm: () => new TLayerOSM,
    stamen: () => new TLayerStamen,
    group: () => new TLayerGroup,
    root: () => new TLayerRoot,
    wms: () => new TLayerWms,
    wmsQgis: () => new TLayerWmsQgis,
    wmsTile: () => new TLayerWmsTile,
};

let uid = 0;

async function create(cnf) {
    let la = _create(cnf.type);
    await la.init(cnf);
    return la;
}


function _create(type) {
    if (!types[type]) {
        throw new Error('Unknown layer type ' + type);
    }
    let la = types[type]();
    la.uid = ++uid;
    return la;
}

//

class TLayer {
    constructor() {
        this.layers = [];
        this.mapLayer = null;
        this.visible = true;
    }

    init(cnf) {
        this.config = cnf;
        if (this.config.visible === false)
            this.visible = false;
    }

    getTitle() {
        return this.config.title;
    }

    getLayers() {
        return this.layers || [];
    }

    addDisplayOptions(opts) {
        if (this.config.minScale)
            opts.minResolution = helpers.scaleToResolution(this.config.minScale);
        if (this.config.maxScale)
            opts.maxResolution = helpers.scaleToResolution(this.config.maxScale);
        if (this.config.opacity)
            opts.opacity = this.config.opacity;
        return opts;
    }

    isEnabled() {
        return true;
    }

    isInScale() {
        let scale = this.map.getScale();
        if (this.config.minScale && scale < this.config.minScale)
            return false;
        if (this.config.maxScale && scale > this.config.maxScale)
            return false;
        return true;
    }

    isVisible() {
        return this.isEnabled() && this.visible;
    }

    isGroup() {
        return this.layers.length > 0;
    }

    changed() {
        this.map.layerTreeChanged();
    }

    setVisible(vis, withChildren) {
        this.visible = vis;
        if (withChildren)
            this.enumerate(la => la.visible = vis);
        this.changed();
    }

    update() {
        if (this.mapLayer)
            this.mapLayer.setVisible(this.visible);
    }

    enumerate(fn, parent = null) {
        fn(this, parent);
        this.layers.forEach(la => la.enumerate(fn, this));
    }

    collect(fn) {
        let res = [];
        this.enumerate(la => {
            let r = fn(la);
            if (!_.isNil(r))
                res.push(r);
        });
        return res;
    }

    getMapLayer() {
        if (!this.mapLayer)
            this.mapLayer = this.createMapLayer();
        return this.mapLayer;
    }

    createMapLayer() {
    }


}

class TLayerGroup extends TLayer {
    async init(cnf) {
        super.init(cnf);
        if (cnf.layers)
            for (let c of cnf.layers)
                this.layers.push(await create(c));
    }

    isVisible() {
        return this.layers.some(la => la.isVisible());
    }

    isEnabled() {
        return this.layers.some(la => la.isEnabled());
    }

    update() {
        this.layers.forEach(la => la.update());
    }
}

class TLayerRoot extends TLayerGroup {
}

class TLayerWms extends TLayerGroup {
    async init(cnf) {

        this.config = cnf;
        this.wmsRoot = true;
        this.shouldRender = false;
        this.shouldCompose = false;

        if (!this.config.caps) {
            let capsDoc = await this.getCapabilities(cnf);
            this.caps = capsDoc.layers[0];
            this.initFromCaps(false);
        } else {
            this.caps = this.config.caps;
            this.shouldRender = true;
            this.visible = this.caps.visible;
        }
        if (cnf.title)
            this.caps.title = cnf.title;
    }

    async getCapabilities(cnf) {
        return await wms.capabilities.load(cnf.url, cnf.params)
    }

    initFromCaps(hasComposer) {
        let ls = this.caps.layers || [];
        delete this.caps.layers;

        this.visible = this.caps.visible;

        if (hasComposer) {
            this.shouldRender = false;
        } else {
            hasComposer = this.config.compose &&
                !!this.caps._pathName.match(new RegExp(this.config.compose));
            this.shouldRender = hasComposer || !ls.length;
            this.shouldCompose = hasComposer;
        }

        for (let caps of ls) {
            let la = _create('wms');
            la.config = {
                ...this.config,
                minScale: caps.minScale,
                maxScale: caps.maxScale,
                opacity: caps.opacity
            };
            la.caps = caps;
            la.initFromCaps(hasComposer);
            this.layers.push(la);
        }
    }

    getTitle() {
        return this.caps.title;
    }

    createMapLayer() {
        if (!this.shouldRender)
            return null;

        let params = this.config.params;

        if (!this.shouldCompose) {
            if (!params.layers && !this.isGroup())
                params.layers = [this.caps.name];
        }

        let source = new ol.source.ImageWMS({
            url: this.config.url,
            params: {
                ...this.config.params,
            },
            ratio: 1,
            preload: 0,
        });

        return new ol.layer.Image({
            source
        });
    }

    isVisible() {
        if (this.isGroup())
            return this.layers.some(la => la.isVisible());
        return this.isEnabled() && this.visible;
    }

    isEnabled() {
        if (this.isGroup())
            return this.layers.some(la => la.isEnabled());
        return this.isInScale(this.caps);
    }

    update() {
        super.update();

        if (this.mapLayer)
            this.mapLayer.setVisible(this.visible);

        if (this.shouldRender) {
            let src = this.mapLayer.getSource();
            src.updateParams({
                ...src.getParams(),
                layers: this.visibleLeaves().map(la => la.caps.name).reverse()
            });
            src.changed();
        } else {
            this.layers.forEach(la => la.update());
        }
    }

    wmsName() {
        return this.isGroup() ? null : this.caps.name;
    }

    wmsLegendURL() {
        return this.isGroup() ? null : this.caps.legendURL;
    }

    async wmsQuery(coordinate) {
        if (!this.isVisible() || !this.caps.queryable)
            return [];

        let leaves = this.visibleLeaves();

        if (!leaves)
            return [];

        let names = leaves.map(la => la.caps.name),
            titles = leaves.map(la => la.caps.title);

        return await wms.query.run(this.map, {
            url: this.config.url,
            params: this.config.params,
            crs: this.caps.crs,
            coordinate,
            layerNames: names,
            layerTitles: titles
        });
    }

    visibleLeaves() {
        return this.collect(la =>
            (!la.isGroup() && la.isVisible()) ? la : null);
    }
}

class TLayerWmsQgis extends TLayerWms {
    async getCapabilities(cnf) {
        return await wms.capabilities.load(cnf.url, cnf.params, 'GetProjectSettings')
    }
}



class TLayerOSM extends TLayer {
    createMapLayer() {
        let source = new ol.source.OSM();
        return new ol.layer.Tile(this.addDisplayOptions({source}));
    }
}


class TLayerStamen extends TLayer {
    createMapLayer() {
        let source = new ol.source.Stamen({
            layer: this.config.layer
        });
        return new ol.layer.Tile(this.addDisplayOptions({source}));
    }
}


class TLayerWmsTile extends TLayer {
    createMapLayer() {
        let source = new ol.source.TileWMS({
            url: this.config.url,
            params: this.config.params
        });
        return new ol.layer.Tile(this.addDisplayOptions({source}));
    }
}

export default {
    create
};